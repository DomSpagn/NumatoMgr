import tkinter as tk
from tkinter import ttk, PhotoImage, messagebox
import serial
import time
import sys
import glob

# This file was generated by the Tkinter Designer
from pathlib import Path

OUTPUT_PATH = Path(__file__).parent

ICON_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\icon")
COVER_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\cover")
MANUAL_PANEL_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\manual\panel")
MANUAL_TEST_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\manual\test")
AUTOMATIC_PANEL_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\automatic\panel")
AUTOMATIC_TEST_PATH = OUTPUT_PATH / Path(r"C:\Users\ITDOSPA\Desktop\NumatoMgr\images\automatic\test")

    
def clear_current_window(current_window):    
    for widget in current_window.winfo_children():
        widget.destroy()

    
def create_debug_window(current_window, msg):
    pass


def get_icon_path(path: str) -> Path:
    return ICON_PATH / Path(path)


def get_cover_path(path: str) -> Path:
    return COVER_PATH / Path(path)


def get_panel_path(type, path: str) -> Path:
    if type == 'manual':
        return MANUAL_PANEL_PATH / Path(path)
    else:
        return AUTOMATIC_PANEL_PATH / Path(path)


def get_test_path(type, path: str) -> Path:
    if type == 'manual':
        return MANUAL_TEST_PATH / Path(path)
    else:
        return AUTOMATIC_TEST_PATH / Path(path)


# Serial COM
def beautify_result(list_in):
    list_out = []
    match len(max(list_in, key = len)):
        case 4:
            for elem in list_in:
                list_out.append("       " + elem + "        ")            
        case 5:
            for elem in list_in:
                list_out.append("     " + elem + "        ")            
        case 6:
            for elem in list_in:
                list_out.append("    " + elem + "       ")            
        
    return list_out       

    
def list_serial_ports():
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
        
    beauty_res = beautify_result(result)
    return beauty_res


def init_system(serialPort):
    are_relays_off = init_relays(serialPort)    
    if not are_relays_off:
        messagebox.showerror("Error", "Cannot initialize relays")
        return False
    
    are_gpios_off = init_gpios(serialPort)
    if not are_gpios_off:
        messagebox.showerror("Error", "Cannot initialize GPIOs")
        return False

    return True


# Baudrate
def get_baudrate_list():
    return ["   2400 bps  ", "   4800 bps  ", "   9600 bps  ", "   19200 bps  ", "   38400 bps  ", "   57600 bps  ", "   115200 bps  ", "   230400 bps  ", "   460800 bps  ", "   500000 bps  ", "   576000 bps  ", "   921600 bps  ", "  1000000 bps  "]


# Relays
def init_relays(ser):
    # set
    rly_w_all_off_cmd = "relay writeall 0000\r"                             # intialize all relays to OFF
    ser.write(rly_w_all_off_cmd.encode())
    time.sleep(0.5)
    #check
    rly_r_all_cmd = "relay readall\r"                                   
    ser.write(rly_r_all_cmd.encode())
    msg = retrieve_answer(ser.read(45).decode(), 'readall', '0000')
    if msg != '0000':
        return False
    
    return True


# GPIOs
def init_gpios(ser):    
    #set
    for gpio_idx in '01234567':
        gpio_w_low_cmd = "gpio clear " + gpio_idx + '\r'                    # set to LOW single GPIO output state
        ser.write(gpio_w_low_cmd.encode())
        time.sleep(0.1)                                                     # wait for 100 ms
        gpio_r_cmd = "gpio read " + gpio_idx + '\r'                         # set to LOW single GPIO output state        
        ser.write(gpio_r_cmd.encode())
        msg = retrieve_answer(ser.read(50).decode(), 'read', '0')
        if msg != '0':
            return False
        
    return True


# General
def retrieve_answer(serial_answer, ref_word, expected_answer):
    # Find the index of the ref_word (reference word)
    ref_word_idx = serial_answer.find(ref_word)
    
    # Check if the ref_word has been found
    if ref_word_idx != -1:
        # Find the index of the expected answer after the reference word
        expected_answer_idx = serial_answer.find(expected_answer, ref_word_idx + len(ref_word))
        
        # Check if the expected answer has been found
        if expected_answer_idx != -1:
            # Return the expected answer
            return serial_answer[expected_answer_idx:expected_answer_idx + len(expected_answer)]
            
        else:
            return ""
    else:
        return ""
